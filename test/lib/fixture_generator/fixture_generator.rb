=begin

Provides the functionality for creating active record objects and associating
fixture names to them and then writing them to yml files.

Usage:

  class MyFixtureGenerator < FixtureGenerator
    def populate
      # Create your records here and add them to the fixture set by calling
      # 'add_record(record_name, record_object)'. That's it!
    end
  end

  MyFixtureGenerator.generate

Copyright (c) 2010 Vikram Venkatesan

=end

class FixtureGenerator
  # Map from model class name to the corresponding table name.
  attr_accessor :models

  # Map from each table name to fixtures for that table name.
  #
  #   {
  #    'users' => {:greg => <object>, :mark => <object>},
  #    'cars'  => {:benz => <object>, :ferrari => <object>}
  #   }
  #
  attr_accessor :object_map

  # Mapping from active record object to the fixture name.
  attr_accessor :fixture_name_map


  # Generates fixture data and writes them to yml files.
  #
  def self.generate(opts = {})
    _generator = self.new(opts)

    _sub_classes = ActiveRecord::Base.descendants
    # Register the models.
    (_sub_classes - (opts[:except] || []) + (opts[:include] || [])).each do |model_klass|
      _generator.register_model(model_klass)
    end
    # counter culture gem will increment/decrement counter in after_commit hooks and commit wont be invoked inside Active record transaction. So don't have ActiveRecord::Base.transaction for fixture generation.
    _generator.populate

    _generator.write_to_file if opts[:write_to_file]
    return _generator
  end

  # Creates the ActiveRecord records to be written to yml files.
  #
  # To be implemented by the project specific generator.
  #
  def populate
    raise NotImplementedError
  end

  # Registers the model with class name +klass+ and corresponding table name
  # +table_name+
  #
  def register_model(klass)
    klass.reset_column_information
    table_name = klass.table_name
    if !(klass.abstract_class? && table_name.nil?)
      self.models[klass] = table_name
      self.object_map[table_name] ||= {}

      self.class_eval do
        # Define accessors for the fixtures for this new model.
        define_method(table_name) do |name|
          self.object_map[table_name][name.to_sym]
        end
      end
    end
  end

  # Writes the generated fixture records to files under 'fixtures' directory.
  #
  # XXX Note that any existing fixtures will be replaced with the new ones by
  # this method.
  #
  def write_to_file
    newline
    say "Writing fixtures to YAML files"
    records_by_table_name = {}

    self.models.each do |model_class, table_name|
      next if model_class == ActiveRecord::SchemaMigration

      all_records = nil
      begin
        all_records = model_class.all # Sometimes calling model_class.all throws exception
      rescue
        puts "\nRetrying..."
      end
      # Load all records of this model.
      records_by_table_name[table_name] ||= []
      records_by_table_name[table_name] += (all_records || model_class.all)
    end

    records_by_table_name.each do |table_name, records|
      next if records.empty?
      # Sequence number for records for which we do not have names.
      i = "0"

      records = records.uniq(&:id)
      yaml_data = records.map do |record|
        # Get the name given for this record while populating. If not
        # available (autogenerated through callbacks), use a sequence number
        # prefixed by the table name.
        fixture_name = get_fixture_name(record) || "#{table_name}_#{i.succ!}"

        attrs = record.attributes
        attrs_to_ignore = []
        attrs_to_ignore += record.translated_attribute_names.map(&:to_s) if record.class.translates?
        attrs_to_ignore += record.tag_types.map { |tag_type| "#{tag_type.to_s.singularize}_list" } if record.respond_to?(:tag_types)
        attrs.except!(*attrs_to_ignore)
        attrs["schedule"] = attrs["schedule"].to_yaml if attrs.key?("schedule")

        # Removes the '---' added at the beginning of each fixture when using to_yaml
        { fixture_name => attrs }.to_yaml.gsub(/^---\n/, "")
      end.join("\n")

      File.open("#{Rails.root}/test/fixtures/#{table_name}.yml", "w") do |file|
        file.write yaml_data
      end
      dot
    end
  end

  private

  # Private constructor for providing a static interface to the generator.
  #
  def initialize(opts = {})
    self.models = opts[:models].presence || {}
    self.object_map = opts[:object_map].presence || {}
    self.fixture_name_map = opts[:fixture_name_map] || {}

    # Lower the logging level since we are about to create many records.
    _logger                   = Logger.new(STDOUT)
    _logger.level             = Logger::ERROR
    ActiveRecord::Base.logger = _logger
  end

  # Adds a fixture +record+ with the given +name+.
  #
  def add_record(name, record)
    klass_map = self.object_map[self.models[record.class]]

    return if klass_map.nil?


    # Panic if attempted to insert duplicate fixture record.
    if klass_map.include?(name.to_sym)
      raise "Duplicate fixture for #{record.class} - #{name}"
    end

    self.fixture_name_map[record] = name.to_s
    klass_map[name.to_sym] = record
    dot

    return record
  end

  def get_fixture_name(record)
    if self.fixture_name_map[record].present?
      self.fixture_name_map[record]
    elsif record.is_a?(Role)
      "#{record.program_id}_#{record.name}"
    end
  end

  ##############################################################################
  # PRINTING
  ##############################################################################

  def say(str)
    print "*** FixtureGenerator :: #{str}"
  end

  def say_populating(model_name)
    newline
    say "Populating #{model_name}"
  end

  def say_updating(model_name)
    newline
    say "Updating #{model_name}"
  end

  def warn(msg)
    print_and_flush "!!! WARNING: #{msg}\n"
  end

  def dot
    print_and_flush(".")
  end

  def newline
    print_and_flush("\n")
  end

  def print_and_flush(msg)
    print msg
    $stdout.flush
  end
end
